#' @rdname IBRAData
#' @export
.IBRAData <- setClass("IBRAData",
                      slots = c(pval = "data.frame", padj = "data.frame",
                                score = "data.frame", truth = "data.frame"))

#' \code{IBRAData} object and constructor
#'
#' The \code{IBRAData} class contains slots to hold calculated p-values,
#' adjusted p-values and general 'scores' for a set of features. The slots can
#' contain values from multiple methods, and each method can contribute to one
#' or more slots. The class also contains a slot giving the 'truth' (a binary
#' assignment and/or a continuous score) for each feature, as well as additional
#' annotations that can be used to stratify the performance calculations.
#'
#' If adjusted p-values are missing for some methods, for which nominal p-values
#' are available, the adjusted p-values can be calculated using the
#' \code{\link{calculate_adjp}} function.
#'
#' The text files generated by \code{IBRAData_to_text} can be used as input to
#' \code{IBRAapp}, when it is called without an input argument.
#'
#' @param pval A data frame with features as rows and methods as columns,
#'   containing nominal p-values. Missing values (\code{NA}s) are allowed. The
#'   row names should be feature names.
#' @param padj A data frame with features as rows and methods as columns,
#'   containing adjusted p-values. Missing values (\code{NA}s) are allowed. The
#'   row names should be feature names.
#' @param score A data frame with features as rows and methods as columns,
#'   containing generic scores. In case of comparison to a binary truth, larger
#'   values of the scores should correspond to 'more significant' features.
#'   Missing values (\code{NA}s) are allowed. The row names should be feature
#'   names.
#' @param truth A data frame with features as rows columns containing feature
#'   annotations such as, e.g., binary and continuous truths and additional
#'   annotations that can be used to stratify the performance calculations. The
#'   row names should be feature names.
#' @param object_to_extend An \code{IBRAData} object to extend with the provided
#'   information.
#'
#' @aliases IBRAData IBRAData-class
#' @return \code{IBRAData}, \code{IBRAData_from_text} and
#'   \code{IBRAData_from_simres} return an \code{IBRAData} object.
#'
#' @docType class
#'
#' @export
#' @rdname IBRAData
#' @author Charlotte Soneson
#' @examples
#' ## Empty IBRAData object:
#' IBRAData()
#'
#' ## IBRAData object from individual data frames
#' set.seed(123)
#' pval <- data.frame(m1 = runif(100), m2 = runif(100),
#'                    row.names = paste0("F", 1:100))
#' truth <- data.frame(status = round(runif(100)),
#'                     row.names = paste0("F", 1:100))
#' ibradata <- IBRAData(pval = pval, truth = truth)
IBRAData <- function(pval = data.frame(), padj = data.frame(),
                     score = data.frame(), truth = data.frame(),
                     object_to_extend = NULL) {

  if (!(is.null(object_to_extend))) {
    if (!(class(object_to_extend) == "IBRAData")) {
      stop("object_to_extend must be a IBRAData object")
    } else {
      if (length(object_to_extend@pval) != 0) {
        if (length(pval) != 0 &&
            length(setdiff(colnames(pval),
                           colnames(object_to_extend@pval))) > 0) {
          pval <- pval[, setdiff(colnames(pval),
                                 colnames(object_to_extend@pval)), drop = FALSE]
          pval <- merge(object_to_extend@pval, pval, by = 0, all = TRUE)
          rownames(pval) <- pval$Row.names
          pval$Row.names <- NULL
        } else {
          pval <- object_to_extend@pval
        }
      }

      if (length(object_to_extend@padj) != 0) {
        if (length(padj) != 0 &&
            length(setdiff(colnames(padj),
                           colnames(object_to_extend@padj))) > 0) {
          padj <- padj[, setdiff(colnames(padj),
                                 colnames(object_to_extend@padj)), drop = FALSE]
          padj <- merge(object_to_extend@padj, padj, by = 0, all = TRUE)
          rownames(padj) <- padj$Row.names
          padj$Row.names <- NULL
        } else {
          padj <- object_to_extend@padj
        }
      }

      if (length(object_to_extend@score) != 0) {
        if (length(score) != 0 &&
            length(setdiff(colnames(score),
                           colnames(object_to_extend@score))) > 0) {
          score <- score[, setdiff(colnames(score),
                                   colnames(object_to_extend@score)),
                         drop = FALSE]
          score <- merge(object_to_extend@score, score, by = 0, all = TRUE)
          rownames(score) <- score$Row.names
          score$Row.names <- NULL
        } else {
          score <- object_to_extend@score
        }
      }

      if (length(object_to_extend@truth) != 0) {
        truth <- object_to_extend@truth
        message(paste0("Non-empty 'truth' slot already exists, and will ",
                       "not be replaced."))
      }
    }
  }
  .IBRAData(pval = pval, padj = padj, score = score, truth = truth)
}

#' @rdname IBRAData
#' @param truth_file A character string giving the path to a file with true
#'   labels and other feature annotations.
#' @param result_files A character vector giving path(s) to file(s) with results
#'   (p-values, adjusted p-values, scores) for one or more methods. The column
#'   names of these files must be of the form "method:measure", where measure is
#'   one of P, adjP or score, depending on what is given in the column.
#' @param feature_id A character string giving the name of the column in the
#'   truth and result files that encodes the feature identifier.
#' @export
IBRAData_from_text <- function(truth_file, result_files, feature_id) {
  truth <- utils::read.delim(truth_file, header = TRUE, as.is = TRUE)
  rownames(truth) <- truth[, feature_id]
  RF <- lapply(result_files, function(f) {
    f <- utils::read.delim(f, header = TRUE, as.is = TRUE, check.names = FALSE)
    if (any(duplicated(f[, feature_id])))
      stop("Duplicate feature IDs found in result file. Please fix.")
    f
  })
  RF <- Reduce(function(...) merge(..., by = feature_id, all = TRUE), RF)
  pval <- RF[, c(feature_id,
                 grep(":P$", colnames(RF), value = TRUE)), drop = FALSE]
  padj <- RF[, c(feature_id,
                 grep(":adjP$", colnames(RF), value = TRUE)), drop = FALSE]
  score <- RF[, c(feature_id,
                  grep(":score$", colnames(RF), value = TRUE)), drop = FALSE]

  if (ncol(pval) == 1) {
    pval <- data.frame()
  } else {
    rownames(pval) <- pval[, feature_id]
    pval <- pval[, grep(":P$", colnames(pval), value = TRUE), drop = FALSE]
    colnames(pval) <- gsub(":P$", "", colnames(pval))
  }

  if (ncol(padj) == 1) {
    padj <- data.frame()
  } else {
    rownames(padj) <- padj[, feature_id]
    padj <- padj[, grep(":adjP$", colnames(padj), value = TRUE), drop = FALSE]
    colnames(padj) <- gsub(":adjP$", "", colnames(padj))
  }

  if (ncol(score) == 1) {
    score <- data.frame()
  } else {
    rownames(score) <- score[, feature_id]
    score <- score[, grep(":score$", colnames(score), value = TRUE),
                   drop = FALSE]
    colnames(score) <- gsub(":score$", "", colnames(score))
  }

  IBRAData(pval = pval, padj = padj, score = score, truth = truth)
}

#' @rdname IBRAData
#' @param ibradata An \code{IBRAData} object
#' @export
IBRAData_to_text <- function(ibradata, truth_file, result_files, feature_id) {
  ## Write truth to file
  truth <- truth(ibradata)
  truth[, feature_id] <- rownames(truth)
  truth <- truth[, c(feature_id,
                     setdiff(colnames(truth), feature_id)), drop = FALSE]
  utils::write.table(truth, file = truth_file, quote = FALSE,
                     sep = "\t", row.names = FALSE, col.names = TRUE)

  ## Merge results and write to file
  pval <- pval(ibradata)
  if (!(length(pval)) == 0)
    colnames(pval) <- paste0(colnames(pval), ":P")
  pval[, feature_id] <- rownames(pval)
  padj <- padj(ibradata)
  if (!(length(padj)) == 0)
    colnames(padj) <- paste0(colnames(padj), ":adjP")
  padj[, feature_id] <- rownames(padj)
  score <- score(ibradata)
  if (!(length(score)) == 0)
    colnames(score) <- paste0(colnames(score), ":score")
  score[, feature_id] <- rownames(score)

  results <- Reduce(function(...) merge(..., by = feature_id, all = TRUE),
                    list(pval, padj, score))

  utils::write.table(results, file = result_files, quote = FALSE,
                     sep = "\t", row.names = FALSE, col.names = TRUE)
}

setMethod("show", "IBRAData",
          function(object) {
            cat("An object of class \"", class(object), "\"\n", sep = "")
            for (sl in slotNames(object)) {
              x <- slot(object, sl)
              cat("@", sl, "\n", sep = "")
              .printHead(x)
              cat("\n")
            }
          })

#' Accessor and replacement functions for \code{pval} slot
#'
#' Accessor and replacement functions for the \code{pval} slot in an
#' \code{IBRAData} object.
#'
#' @docType methods
#' @name pval
#' @rdname pval
#' @aliases pval pval,IBRAData-method pval<-,IBRAData,data.frame-method
#' @return The accessor function returns a data frame containing p-values for
#'   each feature and each method.
#' @param x An \code{IBRAData} object.
#' @param ... Additional arguments.
#' @param value A data frame containing p-values for each feature and each
#'   method.
#' @author Charlotte Soneson
#' @export
#' @examples
#' data(ibradata_example)
#' head(pval(ibradata_example))
setMethod("pval", "IBRAData", function(x) x@pval)
#' @name pval
#' @rdname pval
#' @exportMethod "pval<-"
setReplaceMethod("pval", signature(x = "IBRAData", value = "data.frame"),
                 function(x, value) {
                   x@pval <- value
                   if (validObject(x))
                     return(x)
                 })

#' Accessor and replacement functions for \code{padj} slot
#'
#' Accessor and replacement functions for the \code{padj} slot in an
#' \code{IBRAData} object.
#'
#' @docType methods
#' @name padj
#' @rdname padj
#' @aliases padj padj,IBRAData-method padj<-,IBRAData,data.frame-method
#' @return The accessor function returns a data frame containing adjusted
#'   p-values for each feature and each method.
#' @param x An \code{IBRAData} object.
#' @param ... Additional arguments.
#' @param value A data frame containing adjusted p-values for each feature and
#'   each method.
#' @author Charlotte Soneson
#' @export
#' @examples
#' data(ibradata_example)
#' head(padj(ibradata_example))
setMethod("padj", "IBRAData", function(x) x@padj)
#' @name padj
#' @rdname padj
#' @exportMethod "padj<-"
setReplaceMethod("padj", signature(x = "IBRAData", value = "data.frame"),
                 function(x, value) {
                   x@padj <- value
                   if (validObject(x))
                     return(x)
                 })

#' Accessor and replacement functions for \code{score} slot
#'
#' Accessor and replacement functions for the \code{score} slot in an
#' \code{IBRAData} object.
#'
#' @docType methods
#' @name score
#' @rdname score
#' @aliases score score,IBRAData-method score<-,IBRAData,data.frame-method
#' @return The accessor function regurns a data frame containing scores for each
#'   feature and each method.
#' @param x An \code{IBRAData} object.
#' @param ... Additional arguments.
#' @param value A data frame containing scores for each feature and each method.
#' @author Charlotte Soneson
#' @export
#' @examples
#' data(ibradata_example)
#' head(score(ibradata_example))
setMethod("score", "IBRAData", function(x) x@score)
#' @name score
#' @rdname score
#' @exportMethod "score<-"
setReplaceMethod("score", signature(x = "IBRAData", value = "data.frame"),
                 function(x, value) {
                   x@score <- value
                   if (validObject(x))
                     return(x)
                 })

#' Accessor and replacement functions for \code{truth} slot
#'
#' Accessor and replacement functions for the \code{truth} slot in an
#' \code{IBRAData} object.
#'
#' @docType methods
#' @name truth
#' @rdname truth
#' @aliases truth truth,IBRAData-method truth<-,IBRAData,data.frame-method
#' @return The accessor function returns a data frame containing true
#'   assignments and/or scores for features, together with other feature
#'   annotations to use for stratification of performance calculations.
#' @param x An \code{IBRAData} object.
#' @param ... Additional arguments.
#' @param value A data frame containing true assignments and/or scores for
#'   features, together with other feature annotations to use for stratification
#'   of performance calculations.
#' @author Charlotte Soneson
#' @export
#' @examples
#' data(ibradata_example)
#' head(truth(ibradata_example))
setMethod("truth", "IBRAData", function(x) x@truth)
#' @name truth
#' @rdname truth
#' @exportMethod "truth<-"
setReplaceMethod("truth", signature(x = "IBRAData", value = "data.frame"),
                 function(x, value) {
                   x@truth <- value
                   if (validObject(x))
                     return(x)
                 })

#' Subsetting \code{IBRAData}, \code{IBRAPerformance} or \code{IBRAPlot} objects
#'
#' Functions to subset \code{IBRAData}, \code{IBRAPerformance} or
#' \code{IBRAPlot} objects. \code{IBRAData} objects are subset by features
#' (rows), while \code{IBRAPerformance} and \code{IBRAPlot} objects are subset
#' by methods (columns). Numeric indices are not allowed, since not all slots
#' may be arranged in the same order.
#'
#' @docType methods
#' @name Extract
#' @rdname Extract
#' @aliases \S4method{[}{IBRAData,ANY,ANY} [ [,IBRAData-method
#' @param x An \code{IBRAData}, \code{IBRAPerformance} or \code{IBRAPlot}
#'   object.
#' @param i For \code{IBRAData} objects, a character vector of feature names to
#'   retain.
#' @param j For \code{IBRAPerformance} and \code{IBRAPlot} objects, a character
#'   vector with method names to retain.
#' @param drop not used.
#' @export
setMethod("[", "IBRAData",
          function(x, i, j = "missing", drop = "missing") {
            if (length(x@pval) != 0 &
                length(intersect(rownames(x@pval), i)) == 0)
              stop("None of the provided features found in the pval slot.")
            if (length(x@padj) != 0 &
                length(intersect(rownames(x@padj), i)) == 0)
              stop("None of the provided features found in the padj slot.")
            if (length(x@score) != 0 &
                length(intersect(rownames(x@score), i)) == 0)
              stop("None of the provided features found in the score slot.")
            if (length(x@truth) != 0 &
                length(intersect(rownames(x@truth), i)) == 0)
              stop("None of the provided features found in the truth slot.")
            .pval <- x@pval[match(i, rownames(x@pval)), , drop = FALSE]
            .padj <- x@padj[match(i, rownames(x@padj)), , drop = FALSE]
            .score <- x@score[match(i, rownames(x@score)), , drop = FALSE]
            .truth <- x@truth[match(i, rownames(x@truth)), , drop = FALSE]
            .IBRAData(pval = .pval, padj = .padj, score = .score,
                      truth = .truth)
          })

## Validity
setValidity("IBRAData",
            function(object) {
              msg <- NULL
              valid <- TRUE
              if (length(object@pval) != 0 &
                  !all(sapply(object@pval, is.numeric))) {
                valid <- FALSE
                msg <- c(msg, paste0("pval slot is not numeric"))
              }
              if (length(object@padj) != 0 &
                  !all(sapply(object@padj, is.numeric))) {
                valid <- FALSE
                msg <- c(msg, paste0("padj slot is not numeric"))
              }
              if (length(object@score) != 0 &
                  !all(sapply(object@score, is.numeric))) {
                valid <- FALSE
                msg <- c(msg, paste0("score slot is not numeric"))
              }
              if (length(object@pval) != 0 & length(object@truth) != 0 &
                  length(intersect(rownames(object@pval),
                                   rownames(object@truth))) == 0) {
                valid <- FALSE
                msg <- c(msg, paste0("pval slot does not share any features",
                                     " with truth slot"))
              }
              if (length(object@padj) != 0 & length(object@truth) != 0 &
                  length(intersect(rownames(object@padj),
                                   rownames(object@truth))) == 0) {
                valid <- FALSE
                msg <- c(msg, paste0("padj slot does not share any features",
                                     " with truth slot"))
              }
              if (length(object@score) != 0 & length(object@truth) != 0 &
                  length(intersect(rownames(object@score),
                                   rownames(object@truth))) == 0) {
                valid <- FALSE
                msg <- c(msg, paste0("score slot does not share any features",
                                     " with truth slot"))
              }
              if (valid) TRUE else msg
            })

#' @param simres A \code{benchmarkR::SimResults} object
#' @rdname IBRAData
#' @export
IBRAData_from_simresults <- function(simres) {
  ## Set row names
  if (!is.null(rownames(simres@pval))) {
    rn <- rownames(simres@pval)
    if (is.null(rownames(simres@padj))) {
      rownames(simres@padj) <- rn
    }
  } else if (!is.null(rownames(simres@padj))) {
    rn <- rownames(simres@padj)
    rownames(simres@pval) <- rn
  } else {
    rn <- paste0("F", 1:nrow(simres@pval))
    rownames(simres@pval) <- rn
    rownames(simres@padj) <- rn
  }
  pval <- data.frame(simres@pval, stringsAsFactors = FALSE, check.names = FALSE)
  padj <- data.frame(simres@padj, stringsAsFactors = FALSE, check.names = FALSE)
  truth <- data.frame(row.names = rn, stringsAsFactors = FALSE)
  truth$status = simres@labels
  truth$strat = simres@stratify

  IBRAData(pval = pval, padj = padj, score = data.frame(), truth = truth)
}

#' @param binary_truth The name of the column in truth(ibradata) that contains
#'   the binary truth variable.
#' @param strat (optional) The name of the column in truth(ibradata) that
#'   contains the stratification variable.
#' @rdname IBRAData
#' @export
IBRAData_to_simresults <- function(ibradata, binary_truth, strat = NULL) {
  if (length(pval(ibradata)) == 0)
    stop("ibradata must have non-empty slot pval")
  if (length(pval(ibradata)) == length(padj(ibradata)) &&
      all(colnames(pval(ibradata)) == colnames(padj(ibradata)))) {
    pval <- pval(ibradata)
    padj <- padj(ibradata)
    keep_methods <- colnames(pval)
  } else {
    padj <- NULL
    pval <- pval(ibradata)
    keep_methods <- colnames(pval)
  }

  keep_features <- rownames(truth(ibradata))
  if (!is.null(pval)) keep_features <- intersect(keep_features, rownames(pval))
  if (!is.null(padj)) keep_features <- intersect(keep_features, rownames(padj))

  pval <- pval[keep_features, keep_methods, drop = FALSE]
  padj <- padj[keep_features, keep_methods, drop = FALSE]
  if (!is.null(pval)) pval <- as.matrix(pval)
  if (!is.null(padj)) padj <- as.matrix(padj)
  labels <- truth(ibradata)[keep_features, binary_truth]
  if (!is.null(strat))
    stratify <- truth(ibradata)[keep_features, strat, drop = FALSE]
  else
    stratify <- NULL
  benchmarkR::SimResults(pval = pval, padj = padj,
                         labels = labels, stratify = stratify)
}


