#' @rdname COBRAData
#' @export
.COBRAData <- setClass("COBRAData",
                      slots = c(pval = "data.frame", padj = "data.frame",
                                score = "data.frame", truth = "data.frame"))

#' \code{COBRAData} object and constructor
#'
#' The \code{COBRAData} class contains slots to hold calculated p-values,
#' adjusted p-values and general 'scores' for a set of features. The slots can
#' contain values from multiple methods, and each method can contribute to one
#' or more slots. The class also contains a slot giving the 'truth' (a binary
#' assignment and/or a continuous score) for each feature, as well as additional
#' annotations that can be used to stratify the performance calculations.
#'
#' If adjusted p-values are missing for some methods, for which nominal p-values
#' are available, the adjusted p-values can be calculated using the
#' \code{\link{calculate_adjp}} function.
#'
#' The text files generated by \code{COBRAData_to_text} can be used as input to
#' \code{iCOBRAapp}, when it is called without an input argument.
#'
#' @param pval A data frame with features as rows and methods as columns,
#'   containing nominal p-values. Missing values (\code{NA}s) are allowed. The
#'   row names should be feature names.
#' @param padj A data frame with features as rows and methods as columns,
#'   containing adjusted p-values. Missing values (\code{NA}s) are allowed. The
#'   row names should be feature names.
#' @param score A data frame with features as rows and methods as columns,
#'   containing generic scores. In case of comparison to a binary truth, larger
#'   values of the scores should correspond to 'more significant' features.
#'   Missing values (\code{NA}s) are allowed. The row names should be feature
#'   names.
#' @param truth A data frame with features as rows columns containing feature
#'   annotations such as, e.g., binary and continuous truths and additional
#'   annotations that can be used to stratify the performance calculations. The
#'   row names should be feature names.
#' @param object_to_extend An \code{COBRAData} object to extend with the
#'   provided information.
#'
#' @aliases COBRAData COBRAData-class
#' @return \code{COBRAData} and \code{COBRAData_from_text} return a
#'   \code{COBRAData} object.
#'
#' @docType class
#'
#' @export
#' @rdname COBRAData
#' @author Charlotte Soneson
#' @examples
#' ## Empty COBRAData object:
#' COBRAData()
#'
#' ## COBRAData object from individual data frames
#' set.seed(123)
#' pval <- data.frame(m1 = runif(100), m2 = runif(100),
#'                    row.names = paste0("F", 1:100))
#' truth <- data.frame(status = round(runif(100)),
#'                     row.names = paste0("F", 1:100))
#' cobradata <- COBRAData(pval = pval, truth = truth)
COBRAData <- function(pval = data.frame(), padj = data.frame(),
                     score = data.frame(), truth = data.frame(),
                     object_to_extend = NULL) {

  if (!(is.null(object_to_extend))) {
    if (!(class(object_to_extend) == "COBRAData")) {
      stop("object_to_extend must be a COBRAData object")
    } else {
      if (length(object_to_extend@pval) != 0) {
        if (length(pval) != 0) {
          sds <- setdiff(colnames(pval),
                         colnames(object_to_extend@pval))
          if (length(sds) > 0) {
            pval <- pval[, setdiff(colnames(pval),
                                   colnames(object_to_extend@pval)),
                         drop = FALSE]
            object_to_extend@pval$feature_names_tmp <-
              rownames(object_to_extend@pval)
            pval$feature_names_tmp <- rownames(pval)
            pval <- as.data.frame(dplyr::full_join(object_to_extend@pval, pval,
                                                   by = "feature_names_tmp"))
            rownames(pval) <- pval$feature_names_tmp
            pval$feature_names_tmp <- NULL
          } else {
            pval <- object_to_extend@pval
          }
          message(length(setdiff(rownames(pval),
                                 rownames(object_to_extend@pval))),
                  " new features and ",
                  length(sds), " new methods added to pval table")
        } else {
          pval <- object_to_extend@pval
        }
      } else {
        message(nrow(pval), " new features and ",
                ncol(pval), " new methods added to pval table")
      }

      if (length(object_to_extend@padj) != 0) {
        if (length(padj) != 0) {
          sds <- setdiff(colnames(padj),
                         colnames(object_to_extend@padj))
          if (length(sds) > 0) {
            padj <- padj[, setdiff(colnames(padj),
                                   colnames(object_to_extend@padj)),
                         drop = FALSE]
            object_to_extend@padj$feature_names_tmp <-
              rownames(object_to_extend@padj)
            padj$feature_names_tmp <- rownames(padj)
            padj <- as.data.frame(dplyr::full_join(object_to_extend@padj, padj,
                                                   by = "feature_names_tmp"))
            rownames(padj) <- padj$feature_names_tmp
            padj$feature_names_tmp <- NULL
          } else {
            padj <- object_to_extend@padj
          }
          message(length(setdiff(rownames(padj),
                                 rownames(object_to_extend@padj))),
                  " new features and ",
                  length(sds), " new methods added to padj table")
        } else {
          padj <- object_to_extend@padj
        }
      } else {
        message(nrow(padj), " new features and ",
                ncol(padj), " new methods added to padj table")
      }

      if (length(object_to_extend@score) != 0) {
        if (length(score) != 0) {
          sds <- setdiff(colnames(score),
                         colnames(object_to_extend@score))
          if (length(sds) > 0) {
            score <- score[, setdiff(colnames(score),
                                     colnames(object_to_extend@score)),
                           drop = FALSE]
            object_to_extend@score$feature_names_tmp <-
              rownames(object_to_extend@score)
            score$feature_names_tmp <- rownames(score)
            score <- as.data.frame(dplyr::full_join(object_to_extend@score,
                                                    score,
                                                    by = "feature_names_tmp"))
            rownames(score) <- score$feature_names_tmp
            score$feature_names_tmp <- NULL
          } else {
            score <- object_to_extend@score
          }
          message(length(setdiff(rownames(score),
                                 rownames(object_to_extend@score))),
                  " new features and ",
                  length(sds), " new methods added to score table")
        } else {
          score <- object_to_extend@score
        }
      } else {
        message(nrow(score), " new features and ",
                ncol(score), " new methods added to score table")
      }

      if (length(object_to_extend@truth) != 0) {
        if (length(truth) != 0) {
          truth$feature_names_tmp <- rownames(truth)
          object_to_extend@truth$feature_names_tmp <-
            rownames(object_to_extend@truth)
          tm <- merge(object_to_extend@truth, truth, all = TRUE)
          if (any(duplicated(tm$feature_names_tmp)))
            stop("problem merging truth tables, likely due to ",
                 "inconsistent annotations for one or more features")
          truth <- data.frame(tm, stringsAsFactors = FALSE)
          rownames(truth) <- truth$feature_names_tmp
          truth$feature_names_tmp <- NULL
        } else {
          truth <- object_to_extend@truth
        }
        message(length(setdiff(rownames(truth),
                               rownames(object_to_extend@truth))),
                " new features and ",
                length(setdiff(colnames(truth),
                               colnames(object_to_extend@truth))),
                " new annotations added to truth table")
      } else {
        message(nrow(truth), " new features and ",
                ncol(truth), " new annotations added to truth table")
      }
    }
  }
  .COBRAData(pval = pval, padj = padj, score = score, truth = truth)
}

#' @rdname COBRAData
#' @param truth_file A character string giving the path to a file with true
#'   labels and other feature annotations.
#' @param result_files A character vector giving path(s) to file(s) with results
#'   (p-values, adjusted p-values, scores) for one or more methods. The column
#'   names of these files must be of the form "method:measure", where measure is
#'   one of P, adjP or score, depending on what is given in the column.
#' @param feature_id A character string giving the name of the column in the
#'   truth and result files that encodes the feature identifier.
#' @export
COBRAData_from_text <- function(truth_file, result_files, feature_id) {
  truth <- utils::read.delim(truth_file, header = TRUE, as.is = TRUE)
  rownames(truth) <- truth[, feature_id]
  RF <- lapply(result_files, function(f) {
    f <- utils::read.delim(f, header = TRUE, as.is = TRUE, check.names = FALSE)
    if (any(duplicated(f[, feature_id])))
      stop("Duplicate feature IDs found in result file. Please fix.")
    f
  })
  RF <- Reduce(function(...) merge(..., by = feature_id, all = TRUE), RF)
  pval <- RF[, c(feature_id,
                 grep(":P$", colnames(RF), value = TRUE)), drop = FALSE]
  padj <- RF[, c(feature_id,
                 grep(":adjP$", colnames(RF), value = TRUE)), drop = FALSE]
  score <- RF[, c(feature_id,
                  grep(":score$", colnames(RF), value = TRUE)), drop = FALSE]

  if (ncol(pval) == 1) {
    pval <- data.frame()
  } else {
    rownames(pval) <- pval[, feature_id]
    pval <- pval[, grep(":P$", colnames(pval), value = TRUE), drop = FALSE]
    colnames(pval) <- gsub(":P$", "", colnames(pval))
  }

  if (ncol(padj) == 1) {
    padj <- data.frame()
  } else {
    rownames(padj) <- padj[, feature_id]
    padj <- padj[, grep(":adjP$", colnames(padj), value = TRUE), drop = FALSE]
    colnames(padj) <- gsub(":adjP$", "", colnames(padj))
  }

  if (ncol(score) == 1) {
    score <- data.frame()
  } else {
    rownames(score) <- score[, feature_id]
    score <- score[, grep(":score$", colnames(score), value = TRUE),
                   drop = FALSE]
    colnames(score) <- gsub(":score$", "", colnames(score))
  }

  COBRAData(pval = pval, padj = padj, score = score, truth = truth)
}

#' @rdname COBRAData
#' @param cobradata An \code{COBRAData} object
#' @export
COBRAData_to_text <- function(cobradata, truth_file, result_files, feature_id) {
  ## Write truth to file
  truth <- truth(cobradata)
  truth[, feature_id] <- rownames(truth)
  truth <- truth[, c(feature_id,
                     setdiff(colnames(truth), feature_id)), drop = FALSE]
  utils::write.table(truth, file = truth_file, quote = FALSE,
                     sep = "\t", row.names = FALSE, col.names = TRUE)

  ## Merge results and write to file
  pval <- pval(cobradata)
  if (!(length(pval)) == 0)
    colnames(pval) <- paste0(colnames(pval), ":P")
  pval[, feature_id] <- rownames(pval)
  padj <- padj(cobradata)
  if (!(length(padj)) == 0)
    colnames(padj) <- paste0(colnames(padj), ":adjP")
  padj[, feature_id] <- rownames(padj)
  score <- score(cobradata)
  if (!(length(score)) == 0)
    colnames(score) <- paste0(colnames(score), ":score")
  score[, feature_id] <- rownames(score)

  results <- Reduce(function(...) merge(..., by = feature_id, all = TRUE),
                    list(pval, padj, score))

  utils::write.table(results, file = result_files, quote = FALSE,
                     sep = "\t", row.names = FALSE, col.names = TRUE)
}

setMethod("show", "COBRAData",
          function(object) {
            cat("An object of class \"", class(object), "\"\n", sep = "")
            for (sl in slotNames(object)) {
              x <- slot(object, sl)
              cat("@", sl, "\n", sep = "")
              .printHead(x)
              cat("\n")
            }
          })

#' Accessor and replacement functions for \code{pval} slot
#'
#' Accessor and replacement functions for the \code{pval} slot in an
#' \code{COBRAData} object.
#'
#' @docType methods
#' @name pval
#' @rdname pval
#' @aliases pval pval,COBRAData-method pval<-,COBRAData,data.frame-method
#' @return The accessor function returns a data frame containing p-values for
#'   each feature and each method.
#' @param x An \code{COBRAData} object.
#' @param ... Additional arguments.
#' @param value A data frame containing p-values for each feature and each
#'   method.
#' @author Charlotte Soneson
#' @export
#' @examples
#' data(cobradata_example)
#' head(pval(cobradata_example))
setMethod("pval", "COBRAData", function(x) x@pval)
#' @name pval
#' @rdname pval
#' @exportMethod "pval<-"
setReplaceMethod("pval", signature(x = "COBRAData", value = "data.frame"),
                 function(x, value) {
                   x@pval <- value
                   if (validObject(x))
                     x
                 })

#' Accessor and replacement functions for \code{padj} slot
#'
#' Accessor and replacement functions for the \code{padj} slot in an
#' \code{COBRAData} object.
#'
#' @docType methods
#' @name padj
#' @rdname padj
#' @aliases padj padj,COBRAData-method padj<-,COBRAData,data.frame-method
#' @return The accessor function returns a data frame containing adjusted
#'   p-values for each feature and each method.
#' @param x An \code{COBRAData} object.
#' @param ... Additional arguments.
#' @param value A data frame containing adjusted p-values for each feature and
#'   each method.
#' @author Charlotte Soneson
#' @export
#' @examples
#' data(cobradata_example)
#' head(padj(cobradata_example))
setMethod("padj", "COBRAData", function(x) x@padj)
#' @name padj
#' @rdname padj
#' @exportMethod "padj<-"
setReplaceMethod("padj", signature(x = "COBRAData", value = "data.frame"),
                 function(x, value) {
                   x@padj <- value
                   if (validObject(x))
                     x
                 })

#' Accessor and replacement functions for \code{score} slot
#'
#' Accessor and replacement functions for the \code{score} slot in an
#' \code{COBRAData} object.
#'
#' @docType methods
#' @name score
#' @rdname score
#' @aliases score score,COBRAData-method score<-,COBRAData,data.frame-method
#' @return The accessor function regurns a data frame containing scores for each
#'   feature and each method.
#' @param x An \code{COBRAData} object.
#' @param ... Additional arguments.
#' @param value A data frame containing scores for each feature and each method.
#' @author Charlotte Soneson
#' @export
#' @examples
#' data(cobradata_example)
#' head(score(cobradata_example))
setMethod("score", "COBRAData", function(x) x@score)
#' @name score
#' @rdname score
#' @exportMethod "score<-"
setReplaceMethod("score", signature(x = "COBRAData", value = "data.frame"),
                 function(x, value) {
                   x@score <- value
                   if (validObject(x))
                     x
                 })

#' Accessor and replacement functions for \code{truth} slot
#'
#' Accessor and replacement functions for the \code{truth} slot in an
#' \code{COBRAData} object.
#'
#' @docType methods
#' @name truth
#' @rdname truth
#' @aliases truth truth,COBRAData-method truth<-,COBRAData,data.frame-method
#' @return The accessor function returns a data frame containing true
#'   assignments and/or scores for features, together with other feature
#'   annotations to use for stratification of performance calculations.
#' @param x An \code{COBRAData} object.
#' @param ... Additional arguments.
#' @param value A data frame containing true assignments and/or scores for
#'   features, together with other feature annotations to use for stratification
#'   of performance calculations.
#' @author Charlotte Soneson
#' @export
#' @examples
#' data(cobradata_example)
#' head(truth(cobradata_example))
setMethod("truth", "COBRAData", function(x) x@truth)
#' @name truth
#' @rdname truth
#' @exportMethod "truth<-"
setReplaceMethod("truth", signature(x = "COBRAData", value = "data.frame"),
                 function(x, value) {
                   x@truth <- value
                   if (validObject(x))
                     x
                 })

#' Subsetting \code{COBRAData}, \code{COBRAPerformance} or \code{COBRAPlot}
#' objects
#'
#' Functions to subset \code{COBRAData}, \code{COBRAPerformance} or
#' \code{COBRAPlot} objects. \code{COBRAData} objects are subset by features
#' (rows), while \code{COBRAPerformance} and \code{COBRAPlot} objects are subset
#' by methods (columns). Numeric indices are not allowed, since not all slots
#' may be arranged in the same order.
#'
#' @docType methods
#' @name Extract
#' @rdname Extract
#' @aliases \S4method{[}{COBRAData,ANY,ANY} [ [,COBRAData-method
#' @param x An \code{COBRAData}, \code{COBRAPerformance} or \code{COBRAPlot}
#'   object.
#' @param i For \code{COBRAData} objects, a character vector of feature names to
#'   retain.
#' @param j For \code{COBRAPerformance} and \code{COBRAPlot} objects, a
#'   character vector with method names to retain.
#' @param drop not used.
#' @export
setMethod("[", "COBRAData",
          function(x, i, j = "missing", drop = "missing") {
            if (length(x@pval) != 0 &
                length(intersect(rownames(x@pval), i)) == 0)
              stop("none of the provided features found in the pval slot")
            if (length(x@padj) != 0 &
                length(intersect(rownames(x@padj), i)) == 0)
              stop("none of the provided features found in the padj slot")
            if (length(x@score) != 0 &
                length(intersect(rownames(x@score), i)) == 0)
              stop("none of the provided features found in the score slot")
            if (length(x@truth) != 0 &
                length(intersect(rownames(x@truth), i)) == 0)
              stop("none of the provided features found in the truth slot")
            .pval <- x@pval[match(i, rownames(x@pval)), , drop = FALSE]
            .padj <- x@padj[match(i, rownames(x@padj)), , drop = FALSE]
            .score <- x@score[match(i, rownames(x@score)), , drop = FALSE]
            .truth <- x@truth[match(i, rownames(x@truth)), , drop = FALSE]
            .COBRAData(pval = .pval, padj = .padj, score = .score,
                      truth = .truth)
          })

## Validity
setValidity("COBRAData",
            function(object) {
              msg <- NULL
              valid <- TRUE
              if (length(object@pval) != 0 &
                  !all(sapply(object@pval, is.numeric))) {
                valid <- FALSE
                msg <- c(msg, paste0("pval slot is not numeric"))
              }
              if (length(object@padj) != 0 &
                  !all(sapply(object@padj, is.numeric))) {
                valid <- FALSE
                msg <- c(msg, paste0("padj slot is not numeric"))
              }
              if (length(object@score) != 0 &
                  !all(sapply(object@score, is.numeric))) {
                valid <- FALSE
                msg <- c(msg, paste0("score slot is not numeric"))
              }
              if (length(object@pval) != 0 & length(object@truth) != 0 &
                  length(intersect(rownames(object@pval),
                                   rownames(object@truth))) == 0) {
                valid <- FALSE
                msg <- c(msg, paste0("pval slot does not share any features",
                                     " with truth slot"))
              }
              if (length(object@padj) != 0 & length(object@truth) != 0 &
                  length(intersect(rownames(object@padj),
                                   rownames(object@truth))) == 0) {
                valid <- FALSE
                msg <- c(msg, paste0("padj slot does not share any features",
                                     " with truth slot"))
              }
              if (length(object@score) != 0 & length(object@truth) != 0 &
                  length(intersect(rownames(object@score),
                                   rownames(object@truth))) == 0) {
                valid <- FALSE
                msg <- c(msg, paste0("score slot does not share any features",
                                     " with truth slot"))
              }
              if (valid) TRUE else msg
            })

